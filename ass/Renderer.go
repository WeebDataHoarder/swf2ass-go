package ass

import (
	"fmt"
	"git.gammaspectra.live/WeebDataHoarder/swf2ass-go/ass/line"
	"git.gammaspectra.live/WeebDataHoarder/swf2ass-go/settings"
	"git.gammaspectra.live/WeebDataHoarder/swf2ass-go/types"
	"git.gammaspectra.live/WeebDataHoarder/swf2ass-go/types/math"
	"git.gammaspectra.live/WeebDataHoarder/swf2ass-go/types/shapes"
	"runtime"
	"slices"
	"strconv"
	"sync"
	"sync/atomic"
	"time"
)

type Renderer struct {
	Header        []string
	RunningBuffer []*line.EventLine
	Display       shapes.Rectangle[float64]
}

func NewRenderer(frameRate float64, display shapes.Rectangle[float64]) *Renderer {
	width := int64(display.Width() * settings.GlobalSettings.VideoScaleMultiplier)
	height := int64(display.Height() * settings.GlobalSettings.VideoScaleMultiplier)

	ar := float64(width) / float64(height)

	frameRate *= settings.GlobalSettings.VideoRateMultiplier

	return &Renderer{
		Display: display,
		Header: []string{
			"[Script Info]",
			"; Script generated by swf2ass Renderer",
			"; https://git.gammaspectra.live/WeebDataHoarder/swf2ass-go",
			"Title: swf2ass",
			"ScriptType: v4.00+",
			//TODO: WrapStyle: 0 or 2?
			"WrapStyle: 2",
			"ScaledBorderAndShadow: yes",
			"YCbCr Matrix: PC.709",
			fmt.Sprintf("PlayResX: %d", width),
			fmt.Sprintf("PlayResY: %d", height),
			"",
			"",
			"[Aegisub Project Garbage]",
			"Last Style Storage: f",
			fmt.Sprintf("Video File: ?dummy:%s:10000:%d:%d:160:160:160:c", strconv.FormatFloat(frameRate, 'f', -1, 64), width, height),
			fmt.Sprintf("Video AR Value: %.6F", ar),
			"Active Line: 0",
			"Video Zoom Percent: 2.000000",
			"",
			"[V4+ Styles]",
			"Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding",
			fmt.Sprintf("Style: %s,Arial,20,&H00000000,&H00000000,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,0,0,7,0,0,0,1", line.StyleFill),
			fmt.Sprintf("Style: %s,Arial,20,&H00000000,&H00000000,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,0,0,7,0,0,0,1", line.StyleLine),
			"",
			"[Events]",
			"Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text",
		},
	}
}

func (r *Renderer) RenderFrame(frameInfo types.FrameInformation, frame types.RenderedFrame) (result []string) {
	if len(r.Header) != 0 {
		result = append(result, r.Header...)
		r.Header = nil
	}

	slices.SortStableFunc(frame, RenderedObjectDepthSort)

	var runningBuffer []*line.EventLine

	scale := math.ScaleTransform(math.NewVector2(settings.GlobalSettings.VideoScaleMultiplier, settings.GlobalSettings.VideoScaleMultiplier))

	animated := 0

	for _, object := range frame {
		obEntry := *BakeRenderedObjectsFillables(object)
		object = &obEntry

		object.MatrixTransform = scale.Multiply(object.MatrixTransform) //TODO: order?

		depth := object.GetDepth()

		var tagsToTransition []*line.EventLine

		for i := len(r.RunningBuffer) - 1; i >= 0; i-- {
			tag := r.RunningBuffer[i]
			if depth.Equals(tag.Layer) && object.ObjectId == tag.ObjectId {
				tagsToTransition = append(tagsToTransition, tag)
				r.RunningBuffer = slices.Delete(r.RunningBuffer, i, i+1)
			}
		}
		slices.Reverse(tagsToTransition)

		canTransition := true
		var transitionedTags []*line.EventLine

		for _, tag := range tagsToTransition {
			tag = tag.Transition(frameInfo, object)
			if tag != nil {
				transitionedTags = append(transitionedTags, tag)
				tag.DropCache()
			} else {
				canTransition = false
				break
			}
		}

		if canTransition && len(transitionedTags) > 0 {
			animated += len(transitionedTags)
			runningBuffer = append(runningBuffer, transitionedTags...)
		} else {
			r.RunningBuffer = append(r.RunningBuffer, tagsToTransition...)

			for _, l := range line.EventLinesFromRenderObject(frameInfo, object, settings.GlobalSettings.BakeMatrixTransforms) {
				l.DropCache()
				runningBuffer = append(runningBuffer, l)
			}
		}
	}

	fmt.Printf("[ASS] Total %d objects, %d flush, %d buffer, %d animated tags.\n", len(frame), len(r.RunningBuffer), len(runningBuffer), animated)

	//Flush non dupes
	result = append(result, r.Flush(frameInfo)...)
	r.RunningBuffer = runningBuffer

	return result
}

func threadedRenderer(buf []*line.EventLine, duration time.Duration) []string {
	if len(buf) == 0 {
		return nil
	}
	results := make([]string, len(buf))
	var cnt atomic.Uint64
	var wg sync.WaitGroup
	for i := 0; i < min(len(buf), runtime.NumCPU()); i++ {
		wg.Add(1)
		go func(n int) {
			defer wg.Done()

			for {
				i := cnt.Add(1) - 1
				if i >= uint64(len(buf)) {
					break
				}
				l := buf[i]
				l.Name += fmt.Sprintf(" f:%d>%d~%d", l.Start, l.End, l.End-l.Start+1)
				l.DropCache()
				results[i] = l.Encode(duration)
			}
		}(i)
	}
	wg.Wait()
	return results
}

func (r *Renderer) Flush(frameInfo types.FrameInformation) (result []string) {
	result = threadedRenderer(r.RunningBuffer, frameInfo.GetFrameDuration())
	r.RunningBuffer = r.RunningBuffer[:0]
	return result
}

func BakeRenderedObjectsFillables(o *types.RenderedObject) *types.RenderedObject {
	var baked bool

	drawPathList := make(shapes.DrawPathList, 0, len(o.DrawPathList))

	for _, command := range o.DrawPathList {
		if fillStyleRecord, ok := command.Style.(*shapes.FillStyleRecord); ok && !fillStyleRecord.IsFlat() {
			baked = true
			flattened := fillStyleRecord.Flatten(command.Commands)
			drawPathList = append(drawPathList, flattened...)
		} else {
			drawPathList = append(drawPathList, command)
		}
	}

	if baked {
		return &types.RenderedObject{
			Depth:           o.Depth,
			ObjectId:        o.ObjectId,
			DrawPathList:    drawPathList,
			Clip:            o.Clip,
			ColorTransform:  o.ColorTransform,
			MatrixTransform: o.MatrixTransform,
		}
	} else {
		return o
	}
}

func RenderedObjectDepthSort(a, b *types.RenderedObject) int {
	if len(b.Depth) > len(a.Depth) {
		for i, depth := range b.Depth {
			var otherDepth uint16
			if i < len(a.Depth) {
				otherDepth = a.Depth[i]
			}

			if depth != otherDepth {
				return int(otherDepth) - int(depth)
			}
		}
	} else {
		for i, depth := range a.Depth {
			var otherDepth uint16
			if i < len(b.Depth) {
				otherDepth = b.Depth[i]
			}

			if depth != otherDepth {
				return int(depth) - int(otherDepth)
			}
		}
	}

	return 0
}
